const e=JSON.parse('{"key":"v-35458876","path":"/lc146.html","title":"146. LRU 缓存","lang":"en-US","frontmatter":{"tag":"哈希表"},"headers":[{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]}],"git":{"createdTime":1686143943000,"updatedTime":1686143943000,"contributors":[{"name":"wildpants","email":"492843674@qq.com","commits":1}]},"readingTime":{"minutes":1.82,"words":546},"filePathRelative":"lc146.md","localizedDate":"June 7, 2023","excerpt":"<h1> 146. LRU 缓存</h1>\\n<p><a href=\\"https://leetcode.cn/problems/lru-cache\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://leetcode.cn/problems/lru-cache</a></p>\\n<p>请你设计并实现一个满足&nbsp; LRU (最近最少使用) 缓存 约束的数据结构。\\n实现 LRUCache 类：\\nLRUCache(int capacity) 以 正整数 作为容量&nbsp;capacity 初始化 LRU 缓存\\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\\nvoid put(int key, int value)&nbsp;如果关键字&nbsp;key 已经存在，则变更其数据值&nbsp;value ；如果不存在，则向缓存中插入该组&nbsp;key-value 。如果插入操作导致关键字数量超过&nbsp;capacity ，则应该 逐出 最久未使用的关键字。\\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>"}');export{e as data};
